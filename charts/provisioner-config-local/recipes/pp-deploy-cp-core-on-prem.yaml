#
# Copyright Â© 2024. Cloud Software Group, Inc.
# This file is subject to the license terms contained
# in the license file that is distributed with this file.
#

# Recipe for installing TIBCO Control Plane on-premises
apiVersion: v1
kind: helm-install
meta:
  guiEnv:
    note: "deploy-cp-on-prem"
    # github
    GUI_CP_CHART_REPO: "https://tibcosoftware.github.io/tp-helm-charts"
    GUI_CP_CHART_REPO_USER_NAME: "cp-test"
    GUI_CP_CHART_REPO_TOKEN: ""
    GUI_DP_CHART_REPO: "https://tibcosoftware.github.io/tp-helm-charts"
    GUI_DP_CHART_REPO_USER_NAME: "cp-test"
    GUI_DP_CHART_REPO_TOKEN: ""

    # image registry
    GUI_CP_CONTAINER_REGISTRY: csgprduswrepoedge.jfrog.io
    GUI_CP_CONTAINER_REGISTRY_REPOSITORY: tibco-platform-docker-prod
    GUI_CP_CONTAINER_REGISTRY_USERNAME: ""
    GUI_CP_CONTAINER_REGISTRY_PASSWORD: ""

    # version
    GUI_CP_PLATFORM_BOOTSTRAP_VERSION: 1.3.39
    GUI_CP_PLATFORM_BASE_VERSION: 1.3.358
    # CP env
    GUI_CP_INSTANCE_ID: "cp1"
    GUI_CP_PROVIDER: "local"
    GUI_CP_NAMESPACE: "cp1-ns"
    GUI_CP_ADMIN_EMAIL: "cp-test@tibco.com"
    GUI_CP_LOG_ENABLE: false
    GUI_CP_EXTERNAL_ENVIRONMENT: "production"
    GUI_CP_RESOURCES_REQUEST_CPU: "50m"
    GUI_CP_RESOURCES_REQUEST_MEMORY: "50Mi"
    GUI_CP_EXT_NAMESPACE: "tibco-ext"

    # ingress
    GUI_CP_DNS_DOMAIN: "localhost.dataplanes.pro"
    GUI_TP_TLS_CERT: ""
    GUI_TP_TLS_KEY: ""
    GUI_CP_INGRESS_CLASSNAME: "nginx"
    GUI_CP_SKIP_BOOTSTRAP_INGRESS: false
    GUI_TP_GENERATE_CERTIFICATES: false
    GUI_CP_IDM_IDENTITY_MANAGEMENT_JWT_KEY_STORE_PASSWORD: "easy-to-remember"

    # storage
    GUI_CP_STORAGE_CLASS: "" # user need to choose based on environment
    GUI_CP_STORAGE_CREATE_PV: false
    GUI_CP_STORAGE_PV_NAME: "" # control-plane-pv the name of PV for kind
    GUI_CP_STORAGE_PV_SIZE: "10Gi"

    # email
    GUI_CP_MAIL_SERVER_TYPE: "smtp" # smtp, ses, sendgrid
    GUI_CP_MAIL_SERVER_SES_ARN: ""
    GUI_CP_MAIL_SERVER_SENDGRID_API_KEY: ""
    GUI_CP_MAIL_SERVER_ADDRESS: ""
    GUI_CP_MAIL_SERVER_PORT_NUMBER: "1025"
    GUI_CP_MAIL_SERVER_USERNAME: ""
    GUI_CP_MAIL_SERVER_PASSWORD: ""

    # DB the default value is for postgres pod
    GUI_CP_DB_HOST: "postgresql.tibco-ext.svc.cluster.local"
    GUI_CP_DB_PORT: "5432"
    GUI_CP_DB_USER_NAME: "postgres"
    GUI_CP_DB_PASSWORD: "postgres"
    GUI_CP_DB_NAME: "postgres"
    GUI_CP_DB_SECRET_NAME: "provider-cp-database-credentials"
    GUI_CP_DB_SSL_MODE: "disable" # verify-full, disable
    GUI_CP_DB_SSL_ROOT_CERT: ""
    GUI_CP_DB_DELETE_ON_UNINSTALL: false

    # flow control
    GUI_CP_CREATE_NAMESPACE: true
    GUI_CP_CROSSPLANE_ENABLED: false
    GUI_CP_INSTALL_MAILDEV: true
    GUI_CP_INSTALL_MAILDEV_INGRESS: true
    GUI_CP_INSTALL_PLATFORM_BOOTSTRAP: true
    GUI_CP_INSTALL_PLATFORM_BASE: true

    GUI_CP_INSTALL_TIBCOHUB_CONTRIB: true
    GUI_CP_INSTALL_MSG_CONTRIB: true
    GUI_CP_INSTALL_HAWK: true
    GUI_CP_INSTALL_RECIPES: true
    GUI_CP_INSTALL_INTEGRATION: true
    GUI_CP_INSTALL_INTEGRATION_BWCE: true
    GUI_CP_INSTALL_INTEGRATION_BWCE_UTILITIES: true
    GUI_CP_INSTALL_INTEGRATION_BW5: true
    GUI_CP_INSTALL_INTEGRATION_FLOGO: true
    GUI_CP_INSTALL_INTEGRATION_FLOGO_UTILITIES: true
  globalEnvVariable:
    REPLACE_RECIPE: true
    PIPELINE_LOG_DEBUG: false
    PIPELINE_CHECK_DOCKER_STATUS: false

    # GitHub credentials
    GITHUB_TOKEN: "${GUI_GITHUB_TOKEN}"
    CP_CHART_REPO: ${GUI_CP_CHART_REPO:-"https://tibcosoftware.github.io/tp-helm-charts"} # TIBCO Platform CP public repo
    CP_CHART_REPO_USER_NAME: ${GUI_CP_CHART_REPO_USER_NAME:-"cp-test"}
    CP_CHART_REPO_TOKEN: ${GUI_CP_CHART_REPO_TOKEN:-""}
    DP_CHART_REPO: ${GUI_DP_CHART_REPO:-"https://tibcosoftware.github.io/tp-helm-charts"} # TIBCO Platform DP public repo
    DP_CHART_REPO_USER_NAME: ${GUI_DP_CHART_REPO_USER_NAME:-"cp-test"}
    DP_CHART_REPO_TOKEN: ${GUI_DP_CHART_REPO_TOKEN:-""}

    # container registry
    CP_CONTAINER_REGISTRY: ${GUI_CP_CONTAINER_REGISTRY:-"csgprduswrepoedge.jfrog.io"}
    CP_CONTAINER_REGISTRY_REPOSITORY: ${GUI_CP_CONTAINER_REGISTRY_REPOSITORY:-"tibco-platform-docker-prod"}
    CP_CONTAINER_REGISTRY_USERNAME: "${GUI_CP_CONTAINER_REGISTRY_USERNAME}"
    CP_CONTAINER_REGISTRY_PASSWORD: "${GUI_CP_CONTAINER_REGISTRY_PASSWORD}"

    # env
    CP_CLUSTER_NAME: ${GUI_CP_CLUSTER_NAME:-"cp-cluster"}
    CP_INSTANCE_ID: ${GUI_CP_INSTANCE_ID:-"cp1"}
    CP_PROVIDER: ${GUI_CP_PROVIDER:-local} # deployment target. Example: aws, azure, local.
    CP_NAMESPACE: ${GUI_CP_NAMESPACE:-"${CP_INSTANCE_ID}-ns"}
    CP_ADMIN_EMAIL: ${GUI_CP_ADMIN_EMAIL:-"cp-test@gmail.com"}
    CP_FROM_REPLY_TO_EMAIL: ${GUI_CP_FROM_REPLY_TO_EMAIL:-""}
    CP_LOG_ENABLE: ${GUI_CP_LOG_ENABLE:-false}
    CP_EXTERNAL_ENVIRONMENT: ${GUI_CP_EXTERNAL_ENVIRONMENT:-"production"}
    CP_RESOURCES_REQUEST_CPU: ${GUI_CP_RESOURCES_REQUEST_CPU:-"50m"} # 37 pods * 50m = 1850m
    CP_RESOURCES_REQUEST_MEMORY: ${GUI_CP_RESOURCES_REQUEST_MEMORY:-"50Mi"} # 37 pods * 50Mi = 1850Mi

    # domain
    CP_DNS_DOMAIN: ${GUI_CP_DNS_DOMAIN:-"localhost.dataplanes.pro"}
    CP_SERVICE_DNS_DOMAIN: ${CP_INSTANCE_ID}-my.${CP_DNS_DOMAIN}
    CP_TUNNEL_DNS_DOMAIN: ${CP_INSTANCE_ID}-tunnel.${CP_DNS_DOMAIN}
    # storage
    CP_STORAGE_CLASS: ${GUI_CP_STORAGE_CLASS:-"standard"} # standard, gp2, hostpath, efs-sc
    CP_STORAGE_PV_NAME: "${GUI_CP_STORAGE_PV_NAME}" # control-plane-pv the name of PV for kind, works with CP_STORAGE_CREATE_PV flag
    CP_STORAGE_PV_SIZE: "${GUI_CP_STORAGE_PV_SIZE:-10Gi}"

    # node
    CP_NODE_CIDR: ${GUI_TP_CLUSTER_NODE_CIDR:-"10.180.0.0/16"}
    CP_POD_CIDR: ${GUI_TP_CLUSTER_POD_CIDR:-"10.180.0.0/16"}
    # third party
    CP_EXT_NAMESPACE: ${GUI_CP_EXT_NAMESPACE:-"tibco-ext"}
    # network policies
    CP_CREATE_NETWORK_POLICIES: ${GUI_CP_CREATE_NETWORK_POLICIES:-false}
    # CP DB setup env
    CP_DB_HOST: ${GUI_CP_DB_HOST:-"postgresql.tibco-ext.svc.cluster.local"} #
    CP_DB_PORT: ${GUI_CP_DB_PORT:-"5432"}
    CP_DB_USER_NAME: ${GUI_CP_DB_USER_NAME:-"postgres"} # CP_RDS_USERNAME in create-rds.sh
    CP_DB_PASSWORD: ${GUI_CP_DB_PASSWORD:-"postgres"} # CP_RDS_MASTER_PASSWORD in create-rds.sh
    CP_DB_NAME: ${GUI_CP_DB_NAME:-postgres}
    CP_DB_SECRET_NAME: ${GUI_CP_DB_SECRET_NAME:-provider-cp-database-credentials}
    CP_DB_SSL_MODE: ${GUI_CP_DB_SSL_MODE:-"disable"} # verify-full, disable
    CP_DB_SSL_ROOT_CERT: ${GUI_CP_DB_SSL_ROOT_CERT:-""}
    CP_DB_DELETE_ON_UNINSTALL: ${GUI_CP_DB_DELETE_ON_UNINSTALL:-"false"}
    # CP mail server
    CP_MAIL_SERVER_TYPE: ${GUI_CP_MAIL_SERVER_TYPE:-"smtp"} # smtp, ses, sendgrid
    CP_MAIL_SERVER_SES_ARN: ${GUI_CP_MAIL_SERVER_SES_ARN:-""}
    CP_MAIL_SERVER_SENDGRID_API_KEY: ${GUI_CP_MAIL_SERVER_SENDGRID_API_KEY:-""}
    CP_MAIL_SERVER_ADDRESS: ${GUI_CP_MAIL_SERVER_ADDRESS:-"development-mailserver.${CP_EXT_NAMESPACE}.svc.cluster.local"}
    CP_MAIL_SERVER_PORT_NUMBER: ${GUI_CP_MAIL_SERVER_PORT_NUMBER:-"1025"}
    CP_MAIL_SERVER_USERNAME: ${GUI_CP_MAIL_SERVER_USERNAME:-""}
    CP_MAIL_SERVER_PASSWORD: ${GUI_CP_MAIL_SERVER_PASSWORD:-""}
    # CP SSO
    CP_IDM_IDENTITY_MANAGEMENT_JWT_KEY_STORE_PASSWORD: ${GUI_CP_IDM_IDENTITY_MANAGEMENT_JWT_KEY_STORE_PASSWORD:-"easy-to-remember"}
    # CP ingress
    CP_INGRESS_CLASSNAME: ${GUI_CP_INGRESS_CLASSNAME:-nginx} # the ingress for CP
    CP_SKIP_BOOTSTRAP_INGRESS: ${GUI_CP_SKIP_BOOTSTRAP_INGRESS:-false} # set to false will create ingress for router and hybrid-proxy
    CP_ALB_CERTIFICATE_ARN: "" # AWS ACM certificate ARN for ALB
    CP_NLB_CERTIFICATE_ARN: "" # AWS ACM certificate ARN for NLB
    TP_TLS_CERT: ${GUI_TP_TLS_CERT:-""} # if provided; will create secret tp-certificate with tls.crt and tls.key and create ingress
    TP_TLS_KEY: ${GUI_TP_TLS_KEY:-""}
    TP_GENERATE_CERTIFICATES: ${GUI_TP_GENERATE_CERTIFICATES:-true} # if true, will create cluster issuer and certificate for tp-certificate using cert-manager. For local use set to false
    TP_GENERATE_CERTIFICATE_NAME: tp-certificate-${CP_INSTANCE_ID}
    TP_CERTIFICATE_CLUSTER_ISSUER: ${GUI_TP_CERTIFICATE_CLUSTER_ISSUER:-"tp-prod"} # the cluster issuer for tp-certificate
    # CP version
    CP_PLATFORM_BOOTSTRAP_VERSION: ${GUI_CP_PLATFORM_BOOTSTRAP_VERSION:-1.3.39} # use ^1.0.0 for latest
    CP_PLATFORM_BASE_VERSION: ${GUI_CP_PLATFORM_BASE_VERSION:-1.3.358} # use ^1.0.0 for latest
    # flow control
    CP_CREATE_NAMESPACE: ${GUI_CP_CREATE_NAMESPACE:-true}
    CP_INSTALL_MAILDEV: ${GUI_CP_INSTALL_MAILDEV:-true}
    CP_INSTALL_MAILDEV_INGRESS: ${GUI_CP_INSTALL_MAILDEV_INGRESS:-true}
    CP_STORAGE_CREATE_PV: ${GUI_CP_STORAGE_CREATE_PV:-false} # create PV for control-plane-pv for Kind, MicroK8s and Azure use case
    CP_INSTALL_PLATFORM_BOOTSTRAP: ${GUI_CP_INSTALL_PLATFORM_BOOTSTRAP:-true}
    CP_INSTALL_PLATFORM_BASE: ${GUI_CP_INSTALL_PLATFORM_BASE:-true}
    CP_INSTALL_TIBCOHUB_CONTRIB: ${GUI_CP_INSTALL_TIBCOHUB_CONTRIB:-true}
    CP_INSTALL_MSG_CONTRIB: ${GUI_CP_INSTALL_MSG_CONTRIB:-true}
    CP_INSTALL_HAWK: ${GUI_CP_INSTALL_HAWK:-true}
    CP_INSTALL_RECIPES: ${GUI_CP_INSTALL_RECIPES:-true}
    CP_INSTALL_INTEGRATION: ${GUI_CP_INSTALL_INTEGRATION:-true}
    CP_INSTALL_INTEGRATION_BWCE: ${GUI_CP_INSTALL_INTEGRATION_BWCE:-true}
    CP_INSTALL_INTEGRATION_BWCE_UTILITIES: ${GUI_CP_INSTALL_INTEGRATION_BWCE_UTILITIES:-true}
    CP_INSTALL_INTEGRATION_BW5: ${GUI_CP_INSTALL_INTEGRATION_BW5:-true}
    CP_INSTALL_INTEGRATION_FLOGO: ${GUI_CP_INSTALL_INTEGRATION_FLOGO:-true}
    CP_INSTALL_INTEGRATION_FLOGO_UTILITIES: ${GUI_CP_INSTALL_INTEGRATION_FLOGO_UTILITIES:-true}
  tools:
    yq: "4.40"
preTasks:
- condition: ${CP_CREATE_NAMESPACE}
  clusters:
    - name: ${CP_CLUSTER_NAME}
  script:
    ignoreErrors: false
    fileName: script.sh
    content: |
      # namespace
      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Namespace
      metadata:
        name: ${CP_NAMESPACE}
        labels:
          app.cloud.tibco.com/content: tibco-core
          platform.tibco.com/controlplane-instance-id: ${CP_INSTANCE_ID}
      EOF

      # service account
      kubectl create -n ${CP_NAMESPACE} serviceaccount ${CP_INSTANCE_ID}-sa
      kubectl create clusterrolebinding ${CP_INSTANCE_ID}-sa --clusterrole=cluster-admin --serviceaccount=${CP_NAMESPACE}:${CP_INSTANCE_ID}-sa
      
      # DB password
      kubectl apply -f - <<EOF
      kind: Secret
      apiVersion: v1
      metadata:
        name: ${CP_DB_SECRET_NAME}
        namespace: ${CP_NAMESPACE}
        labels:
          app.kubernetes.io/managed-by: pipeline
      data:
        PASSWORD: $(echo ${CP_DB_PASSWORD} | base64) 
        USERNAME: $(echo ${CP_DB_USER_NAME} | base64)
      type: Opaque
      EOF
      
      # create TP TLS secret if provided
      if [[ -n "${TP_TLS_CERT}" ]]; then
        kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Secret
      metadata:
        name: ${TP_GENERATE_CERTIFICATE_NAME}
        namespace: ${CP_NAMESPACE}
      type: Opaque
      data:
        tls.crt: ${TP_TLS_CERT}
        tls.key: ${TP_TLS_KEY}
      EOF
      fi
      
      # add label to ext namespace
      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Namespace
      metadata:
        name: ${CP_EXT_NAMESPACE}
        labels:
          networking.platform.tibco.com/non-cp-ns: enable
      EOF
      
      # create TP TLS secret if provided
      if [[ -n "${TP_TLS_CERT}" ]]; then
        kubectl apply -f - <<EOF
      apiVersion: v1
      kind: Secret
      metadata:
        name: ${TP_GENERATE_CERTIFICATE_NAME}
        namespace: ${CP_EXT_NAMESPACE}
      type: Opaque
      data:
        tls.crt: ${TP_TLS_CERT}
        tls.key: ${TP_TLS_KEY}
      EOF
      fi
- condition: ${TP_GENERATE_CERTIFICATES}
  clusters:
    - name: ${CP_CLUSTER_NAME}
  script:
    ignoreErrors: false
    fileName: script.sh
    content: |
      kubectl apply -f - << EOF
      apiVersion: cert-manager.io/v1
      kind: Certificate
      metadata:
        name: ${TP_GENERATE_CERTIFICATE_NAME}
        namespace: ${CP_NAMESPACE}
      spec:
        secretName: ${TP_GENERATE_CERTIFICATE_NAME}
        issuerRef:
          name: ${TP_CERTIFICATE_CLUSTER_ISSUER}
          kind: ClusterIssuer
        dnsNames:
          - '*.${CP_SERVICE_DNS_DOMAIN}'
          - '*.${CP_TUNNEL_DNS_DOMAIN}'
      EOF
- condition: ${CP_INSTALL_MAILDEV}
  clusters:
    - name: ${CP_CLUSTER_NAME}
  script:
    ignoreErrors: false
    fileName: script.sh
    content: |
      # install maildev
      function configureLocalSMTP {
        _ext_namespace=${CP_EXT_NAMESPACE}
        #declare variables
        local EMAIL_SERVICE_DEPLOYMENT_NAME=tp-cp-email-service
        local DEVMAIL_SERVICE_NAME=development-mailserver.${_ext_namespace}.svc.cluster.local
        local DEVMAIL_DEPLOYMENT_NAME=maildev
        local DEVMAIL_POD_NAME=maildev
      
        #install maildev deployment
        kubectl apply -f - << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: maildev
          namespace: ${_ext_namespace}
          labels:
            app: maildev
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: maildev
          template:
            metadata:
              labels:
                app: maildev
            spec:
              containers:
                - name: maildev
                  image: maildev/maildev
                  args: ["-s", "1025", "-w", "1080"]
      EOF
      
        #install maildev service:
        kubectl apply -f - <<EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: development-mailserver
          namespace: ${_ext_namespace}
        spec:
          selector:
            app: maildev
          ports:
            - name: smtp
              protocol: TCP
              port: 1025
              targetPort: 1025
            - name: http
              protocol: TCP
              port: 1080
              targetPort: 1080
      EOF
        # wait for pod to be ready
        # echo "waiting for $DEVMAIL_DEPLOYMENT_NAME pod to be ready"
        # kubectl wait deployment $DEVMAIL_DEPLOYMENT_NAME -n ${_ext_namespace} --for=condition=Available=True --timeout=300s
      }
      configureLocalSMTP
- condition: ${CP_INSTALL_MAILDEV_INGRESS}
  clusters:
    - name: ${CP_CLUSTER_NAME}
  script:
    ignoreErrors: false
    fileName: script.sh
    content: |
      if [[ -n "${TP_TLS_CERT}" ]]; then
        kubectl apply -f - <<EOF
      kind: Ingress
      apiVersion: networking.k8s.io/v1
      metadata:
        name: maildev
        namespace: ${CP_EXT_NAMESPACE}
        labels:
          app.cloud.tibco.com/created-by: pipeline
        annotations:
          kubernetes.io/ingress.class: ${CP_INGRESS_CLASSNAME}
          nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
      spec:
        ingressClassName: ${CP_INGRESS_CLASSNAME}
        tls:
        - hosts:
          - '*.${CP_DNS_DOMAIN}'
          secretName: ${TP_GENERATE_CERTIFICATE_NAME}
        rules:
          - host: 'mail.${CP_DNS_DOMAIN}'
            http:
              paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: development-mailserver
                      port:
                        number: 1080
      EOF
      else
        kubectl apply -f - <<EOF
      kind: Ingress
      apiVersion: networking.k8s.io/v1
      metadata:
        name: maildev
        namespace: ${CP_EXT_NAMESPACE}
        labels:
          app.cloud.tibco.com/created-by: pipeline
        annotations:
          kubernetes.io/ingress.class: ${CP_INGRESS_CLASSNAME}
          nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
      spec:
        ingressClassName: ${CP_INGRESS_CLASSNAME}
        rules:
          - host: 'mail.${CP_DNS_DOMAIN}'
            http:
              paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: development-mailserver
                      port:
                        number: 1080
      EOF
      fi
- condition: ${CP_STORAGE_CREATE_PV}
  clusters:
    - name: ${CP_CLUSTER_NAME}
  script:
    ignoreErrors: false
    fileName: script.sh
    content: |
      kubectl apply -f - <<EOF
      apiVersion: v1
      kind: PersistentVolume
      metadata:
        name: ${CP_STORAGE_PV_NAME}
      spec:
        accessModes:
          - ReadWriteMany
        capacity:
          storage: ${CP_STORAGE_PV_SIZE}
        hostPath:
          path: /private/tibco/cp/${CP_STORAGE_PV_NAME}/k8s/volumes/core
          type: DirectoryOrCreate
        persistentVolumeReclaimPolicy: Retain
        volumeMode: Filesystem
        storageClassName: ${CP_STORAGE_CLASS}
      EOF
helmCharts:
- name: platform-bootstrap # router hybrid-proxy compute-service cp-evn certificates
  version: ${CP_PLATFORM_BOOTSTRAP_VERSION}
  condition: ${CP_INSTALL_PLATFORM_BOOTSTRAP}
  repo:
    helm:
      url: ${CP_CHART_REPO}
  values:
    keepPrevious: false
    content: |
      tp-cp-bootstrap:
        compute-services:
          resources:
            requests:
              cpu: ${CP_RESOURCES_REQUEST_CPU}
              memory: ${CP_RESOURCES_REQUEST_MEMORY}
            limits:
              cpu: 1250m
              memory: 1000Mi
          dpHelmRepositories:
            - alias: default
              conf:
                auth:
                  password: ${DP_CHART_REPO_TOKEN}
                  username: ${DP_CHART_REPO_USER_NAME}
                repoUrl: ${DP_CHART_REPO}
              default: true
              type: chart-museum
          dpMetadata:
            dpConfigureNamespaceChartVersion: '*'
            dpCoreInfrastructureChartVersion: '*'
          enabled: true
        hybrid-proxy:
          enabled: true
          resources:
            requests:
              cpu: ${CP_RESOURCES_REQUEST_CPU}
              memory: ${CP_RESOURCES_REQUEST_MEMORY}
            limits:
              cpu: 1250m
              memory: 1000Mi
          ingress:
            enabled: true
            annotations:
              external-dns.alpha.kubernetes.io/hostname: "*.${CP_TUNNEL_DNS_DOMAIN}"
              nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
            ingressClassName: ${CP_INGRESS_CLASSNAME}
            hosts:
              - host: '*.${CP_TUNNEL_DNS_DOMAIN}'
                paths:
                  - path: /
                    pathType: Prefix
                    port: 105
        router-operator:
          enabled: true
          resources:
            requests:
              cpu: ${CP_RESOURCES_REQUEST_CPU}
              memory: ${CP_RESOURCES_REQUEST_MEMORY}
            limits:
              cpu: 3000m
              memory: 1000Mi
          ingress:
            enabled: true
            annotations:
              external-dns.alpha.kubernetes.io/hostname: "*.${CP_SERVICE_DNS_DOMAIN}"
              nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
            ingressClassName: ${CP_INGRESS_CLASSNAME}
            hosts:
              - host: '*.${CP_SERVICE_DNS_DOMAIN}'
                paths:
                  - path: /
                    pathType: Prefix
                    port: 100
        resource-set-operator:
          enabled: true
          resources:
            requests:
              cpu: ${CP_RESOURCES_REQUEST_CPU}
              memory: ${CP_RESOURCES_REQUEST_MEMORY}
            limits:
              cpu: 1000m
              memory: 1000Mi
        otel-collector:
          enabled: false
      global:
        external:
          clusterInfo:
            nodeCIDR: ${CP_NODE_CIDR}
            podCIDR: ${CP_POD_CIDR}
          dnsDomain: ${CP_SERVICE_DNS_DOMAIN}
          dnsTunnelDomain: ${CP_TUNNEL_DNS_DOMAIN}
          provider: ${CP_PROVIDER}
          storage:
            resources:
              requests:
                storage: ${CP_STORAGE_PV_SIZE}
            storageClassName: ${CP_STORAGE_CLASS}
        tibco:
          logging:
            fluentbit:
              enabled: ${CP_LOG_ENABLE} # set to true to enable fluentbit for CP
          containerRegistry:
            url: ${CP_CONTAINER_REGISTRY}
            password: "${CP_CONTAINER_REGISTRY_PASSWORD}"
            username: "${CP_CONTAINER_REGISTRY_USERNAME}"
            repository: "${CP_CONTAINER_REGISTRY_REPOSITORY}"
          controlPlaneInstanceId: ${CP_INSTANCE_ID}
          serviceAccount: ${CP_INSTANCE_ID}-sa
          createNetworkPolicy: ${CP_CREATE_NETWORK_POLICIES}
  cluster:
    names:
      - ${CP_CLUSTER_NAME}
  releaseName: platform-bootstrap
  namespace: ${CP_NAMESPACE}
  flags:
    wait: true
    timeout: 1h
    createNamespace: true
    extra: "--values tls_values.yaml --values volume_values.yaml"
  hooks:
    preDeploy:
      ignoreErrors: false
      base64Encoded: false
      skip: false
      content: |
        # optional chart values fields
        touch tls_values.yaml
        if [[ -n "${TP_TLS_CERT}" || "${TP_GENERATE_CERTIFICATES}" == "true" ]]; then
          export _star_service_dns="'*.${CP_SERVICE_DNS_DOMAIN}'"
          export _star_tunnel_dns="'*.${CP_TUNNEL_DNS_DOMAIN}'"
          export _tp_generate_certificate_name="${TP_GENERATE_CERTIFICATE_NAME}"
          yq eval '(.tp-cp-bootstrap.router-operator.ingress.tls[0].secretName = env(_tp_generate_certificate_name)) | (.tp-cp-bootstrap.router-operator.ingress.tls[0].hosts[0] = env(_star_service_dns)) | .tp-cp-bootstrap.router-operator.ingress.tls[0].hosts[0] style="single" | (.tp-cp-bootstrap.hybrid-proxy.ingress.tls[0].secretName = env(_tp_generate_certificate_name))| (.tp-cp-bootstrap.hybrid-proxy.ingress.tls[0].hosts[0] = env(_star_tunnel_dns)) | .tp-cp-bootstrap.hybrid-proxy.ingress.tls[0].hosts[0] style="single"' tls_values.yaml > tls_values.yaml
          echo "TLS values:"
          cat tls_values.yaml
        fi
        touch volume_values.yaml
        if [[ "${CP_STORAGE_PV_NAME}" != "" ]]; then
          yq eval '.global.external.storage.volumeName = env(CP_STORAGE_PV_NAME)' volume_values.yaml > volume_values.yaml
          echo "Volume values:"
          cat volume_values.yaml
        fi
    postDeploy:
      ignoreErrors: false
      base64Encoded: false
      skip: ${CP_SKIP_BOOTSTRAP_INGRESS}
      content: |
        _router_ingress=$(kubectl get ingress -n ${CP_NAMESPACE} router 2>/dev/null)
        _router_ingress_response=$?
        if [[ -z "${_router_ingress}" && "${_router_ingress_response}" != "0" ]]; then
          if [[ -n "${TP_TLS_CERT}" || "${TP_GENERATE_CERTIFICATES}" == "true" ]]; then
            kubectl apply -f - <<EOF
        kind: Ingress
        apiVersion: networking.k8s.io/v1
        metadata:
          name: router
          namespace: ${CP_NAMESPACE}
          labels:
            app.cloud.tibco.com/created-by: pipeline
            platform.tibco.com/controlplane-instance-id: ${CP_INSTANCE_ID}
          annotations:
            external-dns.alpha.kubernetes.io/hostname: "*.${CP_SERVICE_DNS_DOMAIN}"
            nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
        spec:
          ingressClassName: ${CP_INGRESS_CLASSNAME}
          tls:
          - hosts:
            - '*.${CP_SERVICE_DNS_DOMAIN}'
            secretName: ${TP_GENERATE_CERTIFICATE_NAME}
          rules:
            - host: '*.${CP_SERVICE_DNS_DOMAIN}'
              http:
                paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: router
                        port:
                          number: 100
        EOF
          else
            kubectl apply -f - <<EOF
        kind: Ingress
        apiVersion: networking.k8s.io/v1
        metadata:
          name: router
          namespace: ${CP_NAMESPACE}
          labels:
            app.cloud.tibco.com/created-by: pipeline
            platform.tibco.com/controlplane-instance-id: ${CP_INSTANCE_ID}
          annotations:
            external-dns.alpha.kubernetes.io/hostname: "*.${CP_SERVICE_DNS_DOMAIN}"
            nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
        spec:
          ingressClassName: ${CP_INGRESS_CLASSNAME}
          rules:
            - host: '*.${CP_SERVICE_DNS_DOMAIN}'
              http:
                paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: router
                        port:
                          number: 100
        EOF
          fi
        else 
          echo "Ingress router already exists"
        fi

        _hybrid_proxy_ingress=$(kubectl get ingress -n ${CP_NAMESPACE} hybrid-proxy 2>/dev/null)
        _hybrid_proxy_ingress_response=$?
        if [[ -z "${_hybrid_proxy_ingress}" && "${_hybrid_proxy_ingress_response}" != "0" ]]; then
          if [[ -n "${TP_TLS_CERT}" || "${TP_GENERATE_CERTIFICATES}" == "true" ]]; then
            kubectl apply -f - <<EOF
        kind: Ingress
        apiVersion: networking.k8s.io/v1
        metadata:
          name: hybrid-proxy
          namespace: ${CP_NAMESPACE}
          labels:
            app.cloud.tibco.com/created-by: pipeline
            platform.tibco.com/controlplane-instance-id: ${CP_INSTANCE_ID}
          annotations:
            external-dns.alpha.kubernetes.io/hostname: "*.${CP_TUNNEL_DNS_DOMAIN}"
            nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
        spec:
          ingressClassName: ${CP_INGRESS_CLASSNAME}
          tls:
          - hosts:
            - '*.${CP_TUNNEL_DNS_DOMAIN}'
            secretName: ${TP_GENERATE_CERTIFICATE_NAME}
          rules:
            - host: '*.${CP_TUNNEL_DNS_DOMAIN}'
              http:
                paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: hybrid-proxy  # CP_PROVIDER must set to local to create this service
                        port:
                          number: 105
        EOF
          else
            kubectl apply -f - <<EOF
        kind: Ingress
        apiVersion: networking.k8s.io/v1
        metadata:
          name: hybrid-proxy
          namespace: ${CP_NAMESPACE}
          labels:
            app.cloud.tibco.com/created-by: pipeline
            platform.tibco.com/controlplane-instance-id: ${CP_INSTANCE_ID}
          annotations:
            external-dns.alpha.kubernetes.io/hostname: "*.${CP_TUNNEL_DNS_DOMAIN}"
            nginx.ingress.kubernetes.io/proxy-buffer-size: 16k
        spec:
          ingressClassName: ${CP_INGRESS_CLASSNAME}
          rules:
            - host: '*.${CP_TUNNEL_DNS_DOMAIN}'
              http:
                paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: hybrid-proxy # CP_PROVIDER must set to local to create this service
                        port:
                          number: 105
        EOF
          fi
        else
          echo "Ingress hybrid-proxy already exists"
        fi
- name: platform-base
  version: ${CP_PLATFORM_BASE_VERSION}
  condition: ${CP_INSTALL_PLATFORM_BASE}
  repo:
    helm:
      url: ${CP_CHART_REPO}
  values:
    keepPrevious: false
    content: |
      global:
        cp:
          deleteDBOnUninstall: "${CP_DB_DELETE_ON_UNINSTALL}"
        external:
          environment: ${CP_EXTERNAL_ENVIRONMENT}
          helmRepo: ${CP_CHART_REPO}
          db_host: ${CP_DB_HOST}
          db_name: ${CP_DB_NAME}
          db_password: ${CP_DB_PASSWORD}
          db_port: "${CP_DB_PORT}"
          db_secret_name: ${CP_DB_SECRET_NAME}
          db_ssl_mode: ${CP_DB_SSL_MODE}
          db_ssl_root_cert: "${CP_DB_SSL_ROOT_CERT}"
          db_username: ${CP_DB_USER_NAME}
          emailServerType: ${CP_MAIL_SERVER_TYPE}
          emailServer:
            ses:
              arn: "${CP_MAIL_SERVER_SES_ARN}"
            sendgrid:
              apiKey: "${CP_MAIL_SERVER_SENDGRID_API_KEY}"
            smtp:
              server: ${CP_MAIL_SERVER_ADDRESS}
              port: "${CP_MAIL_SERVER_PORT_NUMBER}"
              username: "${CP_MAIL_SERVER_USERNAME}"
              password: "${CP_MAIL_SERVER_PASSWORD}"
          fromAndReplyToEmailAddress: "${CP_FROM_REPLY_TO_EMAIL}"
          admin:
            email: ${CP_ADMIN_EMAIL}
            firstname: "admin"
            lastname: "admin"
            customerID: "myCustomerID"
          enableLogging: false
          IDENTITY_MANAGEMENT_JWT_KEY_STORE_PASSWORD: "${CP_IDM_IDENTITY_MANAGEMENT_JWT_KEY_STORE_PASSWORD}"
      tp-cp-tibcohub-contrib:
        enabled: ${CP_INSTALL_TIBCOHUB_CONTRIB}
      tp-cp-msg-contrib:
        enabled: ${CP_INSTALL_MSG_CONTRIB}
      tp-cp-hawk:
        enabled: ${CP_INSTALL_HAWK}
      tp-cp-recipes:
        enabled: ${CP_INSTALL_RECIPES}
      tp-cp-integration:
        enabled: ${CP_INSTALL_INTEGRATION}
        tp-cp-integration-common:
          fileserver:
            enabled: true
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        tp-cp-integration-bwce:
          enabled: ${CP_INSTALL_INTEGRATION_BWCE}
          bw-webserver:
            bwwebserver:
              resources:
                requests:
                  cpu: ${CP_RESOURCES_REQUEST_CPU}
                  memory: ${CP_RESOURCES_REQUEST_MEMORY}
                limits:
                  cpu: 200m
                  memory: 200Mi
        tp-cp-integration-bw5:
          enabled: ${CP_INSTALL_INTEGRATION_BW5}
          bw5-webserver:
            bw5webserver:
              resources:
                requests:
                  cpu: ${CP_RESOURCES_REQUEST_CPU}
                  memory: ${CP_RESOURCES_REQUEST_MEMORY}
                limits:
                  cpu: 200m
                  memory: 200Mi
        tp-cp-integration-flogo:
          enabled: ${CP_INSTALL_INTEGRATION_FLOGO}
          flogo-webserver:
            flogowebserver:
              resources:
                requests:
                  cpu: ${CP_RESOURCES_REQUEST_CPU}
                  memory: ${CP_RESOURCES_REQUEST_MEMORY}
                limits:
                  cpu: 200m
                  memory: 200Mi
        tp-cp-bwce-utilities:
          enabled: ${CP_INSTALL_INTEGRATION_BWCE_UTILITIES}
          bwce-utilities:
            studio:
              resources:
                requests:
                  cpu: ${CP_RESOURCES_REQUEST_CPU}
                  memory: ${CP_RESOURCES_REQUEST_MEMORY}
                limits:
                  cpu: "1"
                  memory: 1024Mi
        tp-cp-flogo-utilities:
          enabled: ${CP_INSTALL_INTEGRATION_FLOGO_UTILITIES}
      tp-cp-core:
        admin-webserver:
          replicaCount: 1
          cpadminwebserver:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        cronjobs:
          replicaCount: 1
          cpcronjobservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 100m
                memory: 100Mi
        email-service:
          replicaCount: 1
          providerName: ${CP_PROVIDER} # local or aws, for local will use smtp server
          cpemailservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        identity-management:
          replicaCount: 1
          idm:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 400m
                memory: 400Mi
        identity-provider:
          replicaCount: 1
          tp-cp-identity-provider:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        orchestrator:
          replicaCount: 1
          cporchservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        pengine:
          replicaCount: 1
          tpcppengineservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        user-subscriptions:
          replicaCount: 1
          cpusersubservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        web-server:
          replicaCount: 1
          cpwebserver:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
      tp-cp-core-finops:
        finops-otel-collector:
          resources:
            requests:
              cpu: ${CP_RESOURCES_REQUEST_CPU}
              memory: ${CP_RESOURCES_REQUEST_MEMORY}
            limits:
              cpu: 300m
              memory: 12Gi
        finops-prometheus:
          finopsprometheus:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 300m
                memory: 12Gi
        finops-service:
          finopsservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 250m
                memory: 1024Mi
        finops-web-server:
          replicaCount: "1"
          finopswebserver:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 200m
                memory: 200Mi
        monitoring-service:
          replicaCount: "1"
          monitoringservice:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: 250m
                memory: 1024Mi
          monitoringtibtunnel:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: "80m"
                memory: "200Mi"
          monitoringcapresources:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: "80m"
                memory: "200Mi"
          monitoringhomepagemetrics:
            resources:
              requests:
                cpu: ${CP_RESOURCES_REQUEST_CPU}
                memory: ${CP_RESOURCES_REQUEST_MEMORY}
              limits:
                cpu: "80m"
                memory: "200Mi"
  cluster:
    names:
      - ${CP_CLUSTER_NAME}
  releaseName: platform-base
  namespace: ${CP_NAMESPACE}
  flags:
    wait: true
    timeout: 1h
    createNamespace: true
